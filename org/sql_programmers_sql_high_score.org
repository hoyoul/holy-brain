:PROPERTIES:
:ID:       E47B6B34-BB65-4F0D-9B4E-484E5BF6D1EA
:mtime:    20230731150106 20230731134002 20230731115457 20230731104712 20230731094424 20230729103351 20230728212949 20230728201745 20230728173300 20230728162022 20230728142755 20230728115706 20230728104511 20230728001315 20230727171015
:ctime:    20230727171015
:END:
#+title: [sql] programmers sql high score
#+AUTHOR: holy
#+EMAIL: hoyoul.park@gmail.com
#+DATE: <2023-07-27 Thu>
#+DESCRIPTION: sql programmers 고득점 kit풀기
#+HUGO_DRAFT: true

* introduction
여기에 쓰는것은 누군가가 나에게 sql좀 알려줘 하면 설명해주는 일종의
pattern이다. 그냥 머리속의 생각이라서 대충 이정도는 머리속에 있고
나머지는 검색해서 현업에서 일했다. 즉 아주 기초중의 기초라는
것이다. 하지만, 머리속에 떠오르는 이런 생각이 없으면 개발이
힘들어진다. 누구나 알고 있겠지만, sql은 set theory에 기반한다. 그리고
logic에 대한 개념도 들어가 있다. 이 두 개념에 익숙하다면 그 개념으로
이해해도 된다. 여튼 내가 알고 있는 개념과 Programmers 문제를 풀면서 설명이
필요한것을 적기로 한다. 여기에서 dbms에 관한 sql은 생략한다. 예를 들면
table을 만든다거나, use db로 db를 사용한다거나 이런것들은
생략한다. from where group by having SOL만 다뤄보기로 한다. 그리고
반드시 알아야 하는 집계함수들과 가장 중요한 join만 정리한다. 왜냐면
내가 아는것은 이것밖에 없다. 나머지는 필요에 따라서 검색할 뿐이다.

* 기본 select문
select라는 건 말그대로 선택한다는 것이다. 무엇을 선택하는가? table의
column을 선택한다. table로부터 column을 선택해서 table을
만드는것이다. 일종의 함수다. 정의역도 table, 공역도
table. select문에는 실행 순서가 있다. 보통은 이렇게 외운다.

#+BEGIN_SRC text
from(join) where group by having SOL[select(distint),order by, limit]
#+END_SRC
좀 유치하긴 해도, 이게 기본 실행 순서이고 각각의 keyword는 모든
select문의 기초이기 때문이다.

** from
이제 정의역에 해당하는 table을 기술해보자. 정의역 table을 기술하는
것은 from이다. 왠지 적절한 단어같다. 정의역 table로 부터 원하는
column을 가져와서 table을 만드는 것은 다음과 같다.
#+BEGIN_SRC text
select a,b from Atable
#+END_SRC
이것은 이렇게 해석한다. db에 있는 Atable을 가져온다. 그리고 a,b column
data를 꺼낸다. 이렇게 해석하는 이유는 from이 가장먼저 실행되기
때문이다. 의외로 이것을 모르는 사람이 많이 있어서 적는다.

** where
table에서 a,b컬럼을 가져온다는 것은 data를 포함한 column을 다
가져온다는 것이다. 여기서 특정 조건의 row data만을 가져올 수
있다. 예를 들어보자.

#+BEGIN_SRC text
select district from local where district="busan"
#+END_SRC

where절의 형태를 보자. 선택된 column district의 row를 제한하기위해서
busan과 같다는 조건을 걸었다. 선택된 column이 일종의 변수와 같은
역할을 한다. 이것도 local이라는 table을 db에서 꺼낸다. 그 다음
district가 busan인것만 추린 table에서 district column만 선택해서 꺼낸
table을 return한다. 순서는 다음과 같다. =from => where => select=.

** group by
group by는 특정 column의 row data를 group별로 묶는다. 왜 묶을까?
보통은 집계함수(mma cs)를 사용하려고 묶는다. row를 group으로
묶는다는것을 생각해봐라. 예를 들어 sex라는 column을 group으로 묶으면
어떻게 될까? male 아니면 female이다. 두개밖에 없다. 만일 region이라는
지역으로 group by를 하면 지역별로 하나씩만 나오게 된다. 즉 row data를
summary한 느낌이다. 대표값만을 뽑은 느낌이다. 이렇게 하는 이유는
개개의 row data를 사용하지 않고, mma cs라는 집계함수를 사용하기
위함이다. 이것을 명령어의 동작으로 이해하기 보단, mma cs라는
집계함수를 사용하기 위해선 group by를 사용해야 한다는 관점에서
바라봐야 한다. sex라는 항목을 본다면, 남자는 몇명인가? 키가 180이상인
여자는 몇명인가? 남자의 평균 몸무게는? 가장 몸무게가 많이 나가는
남자는? 이런 질문에 답을 하기 위해선 group by를 사용하는 것이다. 그럼
이제 group by를 어떻게 사용하는지 확인해 보자.

이런 table이 있다고 하자.

#+CAPTION: table
#+NAME: table
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/sql1.png]]

위와 같은 table이 있을때, 다음과 같은 명령을 내린다면 어떻게 될까?
#+BEGIN_SRC text
SELECT Country 
FROM Customers
group by Country
#+END_SRC

수행과정을 보자.  Customers라는 table을 db에서 가져온다. group by
country는 Coutry라는 필드의 data를 대상으로 grouping한다. 즉 대표값만
남는다. 그래서 21개의 row가 있다. 여기서 select Country하면 대표값만
남은 Coutry column만 있는 table을 return한다.

#+CAPTION: groupby1
#+NAME: groupby1
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/groupby1.png]]

이것은 기존에 있던 table의 row에서 대표값만을 가져온다고 했다. 그래서
21개의 row만 가져온다. 원래 table에 Germany라는 값을 갖는 row는 여러개
있지만 하나만 남게된다.

#+CAPTION: groupby2
#+NAME:groupby2
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/groupby2.png]]


그럼 다음과 같은 명령은 어떻게 될까?
#+BEGIN_SRC text
SELECT *
FROM Customers
group by Country
#+END_SRC

Customers table을 db에서 가져온다. group by Country를 실행하면,
Country의 대표값만 남는다. 이 상태에서 select *를 하면 아래와 같은
결과를 갖는다.

#+CAPTION: groupby3
#+NAME:groupby3
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/groupby3.png]]

여기서 group by로 대표값만 남게 한 상태에서 select *로 모든 column을
가져온다. 여기서 한가지 궁금한 점이 생긴다. 그림에서도 표시했지만,
Germany의 경우 Germany값을 갖는 row가 한개가 아니다. 그러면 어떤 row를
가져와 표시하는가? 하는 질문을 할 수 있다. 답은 제일 첫번째 위치의
row를 가져온다. 그리고 결과를 보면 Country대표값의 개수만큼 row가
있다는 것도 알 수 있다. 그런데 group by를 사용하는 것은 단순히 group
by를 select distinct Country처럼 사용할려는게 아니다. group by는
group으로 모은 대표값들의 개수라던가, 합이라던가, min,max,average를
알고 싶을때 사용한다. 특정 목적이 있다. 그런 예를 보자.

#+BEGIN_SRC text
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;
#+END_SRC

customer table을 db에서 가져오고 Country로 grouping을 했다. 그러면
country column의 row들은 대표값만 갖게 된다. 여기서 select문의 해석이
달라진다. 집계함수가 사용되기 때문이다. GroupBy로 기준이되는
column값이 정해졌다. 여기서 count(column)이 사용되는데, 즉 기준값에
해당하는 group이 가지고 있는 rows에 대해서 계산을 하는것이다. 위에서는
count(customerid)로 되어 있기 때문에, 각각의 대표값에 해당하는 group이
가지고 있는 row들에 대한 개수값을 계산한다. 만일 Max(CustomerID)로
하면 각 group이 가지고 있는 row중에 최대 id값을 return하게 되는
것이다. average도 마찬가지다. select문에 집계함수 옆의 Country는 그냥
알아보기 좋게 하려고 추가한 것이다. 결과는 다음과 같다.

#+CAPTION: count
#+NAME: count
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/count1.png]]

max에 대한 처리 결과도 다음과 같다.

#+CAPTION: max
#+NAME: max
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/max1.png]]

avg에 대한 처리 결과는 다음과 같다.
#+CAPTION: avg
#+NAME: avg
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/avg1.png]]

내가 알고 있는 group by는 이게 전부다.

*** group by에 대한 좋은 예
위에 있는 예는 좀 보기 어렵다. group by로 group화하고 집계함수 쓰는게
있어서 web에서 긁어왔다. 출처는 다음과 같다. [[https://makand.tistory.com/entry/SQL-HAVING-%EA%B5%AC%EB%AC%B8][여기]]

#+CAPTION: example1
#+NAME: exmaple
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/exam1.png]]


** having
having은 group by에 포함되는 건데, 외울때 group by having SOL로 외워서
별도로 해놓았다. 다른곳에선 group by로 group을 만든 후에 having으로
조건을 건다고 한다. 그런데 내가 봤을때 보통 having으로 조건을 걸고
group by로 grouping하는 순서가 아닐까 한다. 여튼 그렇다. sql문
작성순서는 group by다음에 위치한다. 다시한번 말하면 나는 =having절은
group by를 하기전에 먼저 조건을 거는 것= 이라고 생각한다. 조건을 걸때
보통 집계함수를 사용해서 제한을 건다. 위에서 좋은예로 설명한 곳에서
having도 같이 설명했기때문에 붙여넣는다.

#+CAPTION: example2
#+NAME: exmaple2
#+attr_html: :width 600px
#+attr_latex: :width 100px
[[../static/img/sql/exam2.png]]

sql을 해석하면 다음과 같다. coffee라는 table을 db에서
가져온다. group으로 묶기 전에 having을 먼저 처리한다. 즉 coffee name이
하나 이상인걸로 조건을 걸어버린다. 그러면 아메리카노 밖에 없다. 여기서
group by를 하면 아메리카노밖에 없다.

** select
*** distinct
distinct는 중복을 피하는 keyword다. select절에 포함된다. select절을
수행할 때 실행되는데, 굉장히 많이 쓰이는 편이다. 예를 들면,
#+BEGIN_SRC text
select distinct people_id from Atable where city='인천'
#+END_SRC
이런 식으로 사용된다. 이것이 의미하는 것은 Atable을 db에서
가져온다. city가 인천인 table을 만든다. 이런 table에서 peple_ID가
중복되지 않은 column을 꺼내서 return한다. select distinct가 하나의
절이다.
*** 집계함수
mma cs로 외우자. min,max,average 그리고 count, sum이다. 가장 많이
쓰이는 집계함수다.
** order by
order by는 내림차순에 해당하는 desc, 오름차순에 해당하는 asc가
있다. 내림차순이라는건 row의 order(순서)가 내려갈수록 값이
낮아지는것이고 오름차순은 row의 order(순서)가 내려갈 수록 값이 커지는
것을 말한다. 사용법은 단순하다.
#+BEGIN_SRC text
order by 컬럼 desc, 컬럼 asc 
#+END_SRC
이런 식으로 추가하면 된다. from으로 table을 가져오고 where로 row를
제한하고, 여기서 having과 groupby로 group화해서 table을 만든다. 여기에
select로 원하는 table을 return하기 위해서 column을 선택한다. 그런
다음에, order by로 정렬을 한다. order by는 너무 단순해서 예를 들진
않겠다.

** limit
limit은 최종 return할 table이 만들어졌을 때, row수를 제한한다.
사용법은 다음과 같다.
#+BEGIN_SRC text
  limit 시작점, 개수
  limit 2,1
#+END_SRC
 limit 2,1은 3번째 row의 row 1개만 보여준다.

** 요약
이것이 기본적인 select문의 구조다.

* join

** 상식적으로 join을 보자.
하나의 table에서 column을 선택해서 table을 만드는게 아니라, 2개의
table에서 column을 뽑아내서 만들 수는 없나? 그럴려면 2개의 table을
기술해야 한다. 예를 들어서,
#+BEGIN_SRC text
select a,b from Atable, Btable
#+END_SRC
위와 같은 형태로 기술할 수 있다. 근데 a와 b는 Atable의 column인가?
아니면 Btable의 column인가? a,b라는 column은 Atable에도 Btable에도
있을 수 있다. 따라서 이런 표기법은 문제가 있다. 다음 표기법은 어떤가?

#+BEGIN_SRC text
select Atable.a,Btable.b from Atable, Btable
#+END_SRC

일견 그럴싸하다. a라는 column은 Atable에서 선택한다는 명확한
의미전달이 가능하기 때문이다. 그럼 다음과 같은 상황을 살펴보자.

#+BEGIN_SRC text
select SeoulElementarySchoolTeachers.a, BusanPeopleTable.b from SeoulElementarySchoolTeachers, BusanPeopleTable
#+END_SRC

뭔가 불편하지 않은가? 그렇다. table 이름이나 column name이 길면 as를 사용한다.

** as 사용법
as 사용법은 다음과 같다. 컬럼의 경우,
#+BEGIN_SRC text
SELECT column_name AS alias_name
FROM table_name;
#+END_SRC

table의 경우,
#+BEGIN_SRC text
SELECT column_name(s)
FROM table_name AS alias_name;
#+END_SRC

이것에 맞추어 다시 수정해보자.

#+BEGIN_SRC text
select SeoulElementarySchoolTeachers.a, BusanPeopleTable.b from SeoulElementarySchoolTeachers, BusanPeopleTable
#+END_SRC

table명만 길기 때문에 from에서 바꿔주면 된다.
#+BEGIN_SRC text
select Seoul.a, Busan.a from SeoulElementarySchoolTeachesr as Seoul, BusanPeopleTable as Busan
#+END_SRC


** join의 적용
위에서 작성한 sql문은 그럴듯하지만 이렇게 사용되지 않는다.
#+BEGIN_SRC text
select Seoul.a, Busan.b from SeoulElementarySchoolTeachesr as Seoul, BusanPeopleTable as Busan
#+END_SRC

무엇을 고쳐야 할까? from에는 하나의 table만 온다. 만일 2개의 table을
불러올려면, join을 사용한다. join은 2개의 table을 연결해서 하나로
만든다는 얘기다. 그래서 연산이 존재한다. 어떻게 하나로 만들것인가?에
대한 연산이다. 그런데 상식적으로 2개의 table을 하나로 합친다는게 말이
안된다. A라는 table에 B라는 table의 column들을 그냥 떼다가 A에
붙일수는 있다. 그러면 이게 제대로된 table일까? A라는 table은 고객에
대한 정보를 갖는 table이라고 하자. B는 쇼핑아이템에 대한 정보라고
하자. 그냥 두개의 table을 합쳤다면 사람에 대한 정보와 쇼핑아이템에
대한 정보가 아무런 연관도 없는데 그냥 연결해 버린 것이다. table을
무조건 합치면 안된다.

*** ON의 사용
그래서 On이라는게 사용된다. On은 2개의 table을 연결하는 공통적인
접점(column)을 의미한다. 사용법은 다음과 같다.

#+BEGIN_SRC text
  select A.process_id, B.date, B.name
  from A inner join B on A.id = B.id    
#+END_SRC
다른 것보다 같은 컬럼을 합치는 부분을 보면된다.
#+BEGIN_SRC text
on A.id = B.id
#+END_SRC
